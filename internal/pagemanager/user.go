package pagemanager

import (
	"github.com/gorilla/websocket"
	"time"
	"log"
	"github.com/edwardwohaijun/file-transfer/internal/generate"
	"fmt"
	"encoding/json"
	"errors"
)

const (
	writeWait = 10 * time.Second // Time allowed to write a message to the peer.
	pongWait = 60 * time.Second // Time allowed to read the next pong message from the peer.
	pingPeriod = (pongWait * 9) / 10 // Send pings to peer with this period. Must be less than pongWait.
	maxMessageSize = 2048 // Maximum message size allowed from peer. Any msg larger than this cause socket to close, how to deal with that?
)

// parseClientMessage parse the user-sent websocket msg, there are only 2 types of msg: the RenameUserMsg and signaling msg sent by webRTC library "simple-peer",
// these 2 types can't be declared in a single object,
// Thus, this function try to parse the signaling type, then the Rename type if 1st type failed.
func parseClientMessage(jsonStr []byte, msgObj *Message) error {
	signalingMsg := &SignalingData{} // signaling data is generated by the underlying simple-filer library, it's not Message{} compliant, need to be wrapped in Message{} format
	if err := json.Unmarshal(jsonStr, &signalingMsg); err == nil && signalingMsg.SignalingData != nil {
		msgObj.Type = SignalingMsg
		msgObj.Content = signalingMsg
		return nil
	}

	if err := json.Unmarshal(jsonStr, msgObj); err == nil && msgObj.Type == RenameUserMsg {
		return nil
	}
	return errors.New("err parsing msg sent from websocket client") // 2 types of error: invalid signaling data, invalid rename msg
}

// NewUser is invoked when socket connection is successfully created, and returns a user object. This object requires a *Page field(we pass a dummy &Page{Id: pid} object.
// At this moment, we don't know whether this Page object exists in fileManager or not. Caller will send the user object to pagemanager.handleUserJoin(userObj)
// pageManager will decide whether to use the existing page object or create a new one based on pageId.
func NewUser(pid pageId, socket *websocket.Conn) *User {
	uid := generate.RandomString(userIdLength)
	return &User{
		Id: userId(uid),
		Name: uid,
		Page: &Page{
			Id: pid,
		},
		Socket: socket,
		PeerMsg: make(chan *Message, 4),
	}
}

// readPump reads data from websocket of browser side, then send it to Page object
func (u *User) readPump() {
	defer func() {
		u.Page.sendUserData(u, false)
		u.Socket.Close()
	}()
	u.Socket.SetReadLimit(maxMessageSize)
	u.Socket.SetReadDeadline(time.Now().Add(pongWait))
	u.Socket.SetPongHandler(func(string) error { u.Socket.SetReadDeadline(time.Now().Add(pongWait)); return nil })
	for {
		_, message, err := u.Socket.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				log.Printf("error: %v", err)
			}
			break
		}
		msgObj := Message{}
		if err := parseClientMessage(message, &msgObj); err != nil {
			fmt.Println("err unmarshaling msg: ", err)
			continue
		}
		if ok := u.Page.sendMsgData(&msgObj); !ok {
			return
		}
	}
}

// writePump reads data from User.Peermsg channel(sent by Page), send it back to websocket of browser side.
func (u *User) writePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		u.Socket.Close()
	}()

	for {
		select {
		case message := <-u.PeerMsg:
			u.Socket.SetWriteDeadline(time.Now().Add(writeWait))
			// todo: don't call WriteJSON, marshal the msg first, then call socket.WriteMessage
			// and don't call WriteMessage concurrently. Use lock if have to.
			// if err := u.Socket.WriteMessage(websocket.TextMessage, JSONMsg); err != nil {
			if err := u.Socket.WriteJSON(message); err != nil {
				log.Println("err writeMsg: ", err)
				return // 一旦出错, 就return, 不好吧. 但一般此类err多数是: client is dead/stuck, 不return还能匝地?
			}
		case <-ticker.C:
			u.Socket.SetWriteDeadline(time.Now().Add(writeWait))
			if err := u.Socket.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}
